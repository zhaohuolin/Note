## 构造函数与析构函数

### 构造函数的调用顺序

1. 基类构造顺序由派生层次决定：**最远的基类最先构造** ，成员构造顺序和定义顺序符合 

2. **析构函数**的析构顺序与构造顺序相反；

3. 没有构造函数的派生类也会调用基类的构造函数；如果基类构造函数需要参数，那么派生类就必须要有构造函数去传参给基类构造函数；

4. 派生类构造函数 派生类可能有多个基类，也可能包括多个成员对象，在创建派生类对象时，派生类的构造函数除了要负责本类成员的初始化外，还要调用基类和成员对象的构造函数，并向它们传递参数，以完成基类子对象和成员对象的建立和初始化。派生类构造函数的参数传递给基类构造初始化  `Son(int a,int b,int l):Father(a,b)`

   

   构造顺序：

   ​	**基类 --> 按定义顺序的成员 --> 自身**

   析构顺序：

   ​	**自身 --> 按定义顺序的成员 --> 基类**

   

   **注**：**派生类只能采用构造函数初始化列表的方式向基类或成员对象的构造函数传递参数**，形式如下：

   派生类构造函数名(参数表):基类构造函数名(参数表),成员对象名1(参数表),…{ //…… }

   即：`D( ) : B(1),a4(4),c2(2),c1(1)`

   ```C++
   //Eg6-12.cpp
   #include <iostream>
   using namespace std;
   class A {
       int x;
   public:
        A(int i=0) {
            x=i;
            cout << "A-----"<<x<<endl;
        }
   };
   class B {
       int y;
   public:
       B(int i) {
           y=i;
           cout << "B-----"<<y<<endl;
       } 
   }; 
   class C {
       int z;
   public:
       C(int i) {
           z=i;
           cout << "C-----"<<z<<endl;
       } 
   };
   class D : public B{
   public: 
       A *a1 = new A(10);
       C c1, c2;
       A a0,a4;
       D( ) : a4(4),c2(2),c1(1),B(1) {
   cout << "D-----5"<<endl;
       }
   };
   int main(){
       D d;
       system("pause");
   }
   
   /*
   B-----1
   A-----10
   C-----1
   C-----2
   A-----0
   A-----4
   D-----5
   */
   ```

